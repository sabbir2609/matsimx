#!/bin/bash

# Concentration sweep script for Fe-La system
# Generated by SimplySQS
# Corrdump command: corrdump -l=rndstr.in -ro -noe -nop -clus -2=3.0 -3=1.0
# Total sites in supercell: 32
# Parallel runs per concentration: 5
# Maximum concurrent jobs: 6
# Concentrations: [0.03125, 0.0625, 0.09375, 0.125, 0.15625, 0.1875, 0.21875, 0.25, 0.28125, 0.3125, 0.34375, 0.375, 0.40625, 0.4375, 0.46875, 0.5, 0.53125, 0.5625, 0.59375, 0.625, 0.65625, 0.6875, 0.71875, 0.75, 0.78125, 0.8125, 0.84375, 0.875, 0.90625, 0.9375, 0.96875]
# Total estimated time: 930.0 minutes

set -e

SWEEP_ELEMENT="Fe"
COMPLEMENT_ELEMENT="La"
TIME_PER_CONC_DEFAULT=30.0
MAX_PARALLEL=6
PARALLEL_RUNS_PER_CONC_DEFAULT=5
CORRDUMP_CMD="corrdump -l=rndstr.in -ro -noe -nop -clus -2=3.0 -3=1.0"
MCSQS_BASE_CMD="mcsqs -rc"
MCSQS_MODE="Supercell Mode"
PROGRESS_UPDATE_INTERVAL=10

TOTAL_TIME_SECONDS=$(echo "$TIME_PER_CONC_DEFAULT * 60" | bc | xargs printf "%.0f")

GLOBAL_START_TIME=$(date +%s)
declare -A CONC_START_TIMES
declare -A CONC_BEST_SCORES
declare -A CONC_BEST_RUNS

echo "üöÄ Starting concentration sweep..."
echo "üî¨ Sweep element: $SWEEP_ELEMENT"
echo "üî¨ Complement element: $COMPLEMENT_ELEMENT"
echo "üß™ Corrdump command: $CORRDUMP_CMD"
echo "‚öôÔ∏è MCSQS mode: $MCSQS_MODE"
echo "‚öôÔ∏è MCSQS command: $MCSQS_BASE_CMD"
echo "‚è±Ô∏è Default time per concentration: $TIME_PER_CONC_DEFAULT minutes"
echo "‚öôÔ∏è Default parallel runs per concentration: $PARALLEL_RUNS_PER_CONC_DEFAULT"
echo "üîç Concentrations to be searched: [0.03125, 0.0625, 0.09375, 0.125, 0.15625, 0.1875, 0.21875, 0.25, 0.28125, 0.3125, 0.34375, 0.375, 0.40625, 0.4375, 0.46875, 0.5, 0.53125, 0.5625, 0.59375, 0.625, 0.65625, 0.6875, 0.71875, 0.75, 0.78125, 0.8125, 0.84375, 0.875, 0.90625, 0.9375, 0.96875]"

mkdir -p best_poscars
echo "üìÇ Created folder best_poscars to store the best structures from each concentration."

cleanup() {
    echo "üßπ Cleaning up background processes..."
    jobs -p | xargs -r kill 2>/dev/null || true
    wait
}

trap cleanup EXIT INT TERM

format_elapsed_time() {
    local elapsed=$1
    local days=$((elapsed / 86400))
    local hours=$(((elapsed % 86400) / 3600))
    local minutes=$(((elapsed % 3600) / 60))
    local seconds=$((elapsed % 60))
    printf '%02d:%02d:%02d:%02d' $days $hours $minutes $seconds
}

extract_latest_objective() {
    grep "Objective_function=" "$1" | tail -1 | sed "s/.*= *//" 2>/dev/null || echo ""
}

extract_latest_step() {
    grep -c "Objective_function=" "$1" 2>/dev/null || echo "0"
}

get_best_objective_and_run() {
    local best_obj="N/A"
    local best_run="N/A"
    local parallel_runs_per_conc=$1

    if [ $parallel_runs_per_conc -gt 1 ]; then
        for ((i=1; i<=parallel_runs_per_conc; i++)); do
            if [ -f "mcsqs$i.log" ]; then
                local current_obj=$(extract_latest_objective "mcsqs$i.log")
                if [ -n "$current_obj" ] && [ "$current_obj" != "N/A" ] && [ "$current_obj" != "" ]; then
                    if [ "$best_obj" = "N/A" ] || awk "BEGIN {exit !($current_obj < $best_obj)}" 2>/dev/null; then
                        best_obj="$current_obj"
                        best_run="$i"
                    fi
                fi
            fi
        done
    else
        if [ -f "mcsqs.log" ]; then
            local current_obj=$(extract_latest_objective "mcsqs.log")
            if [ -n "$current_obj" ] && [ "$current_obj" != "N/A" ] && [ "$current_obj" != "" ]; then
                best_obj="$current_obj"
                best_run="1"
            fi
        fi
    fi

    echo "$best_obj,$best_run"
}

initialize_concentration_csv() {
    local conc=$1
    local parallel_runs_per_conc=$2
    local csv_file="optimization_data_${conc}.csv"

    # Create CSV header
    if [ $parallel_runs_per_conc -gt 1 ]; then
        header="Minute,Timestamp,Best_Objective,Best_Run"
        for ((i=1; i<=parallel_runs_per_conc; i++)); do
            header="$header,Run${i}_Steps,Run${i}_Objective,Run${i}_Status"
        done
    else
        header="Minute,Timestamp,Steps,Objective_Function,Status"
    fi

    echo "$header" > "$csv_file"
    echo "$csv_file"
}

log_to_csv() {
    local csv_file=$1
    local conc=$2
    local parallel_runs_per_conc=$3
    local elapsed_minutes=$4

    local current_time=$(date +'%Y-%m-%d %H:%M:%S')
    local result=$(get_best_objective_and_run $parallel_runs_per_conc)
    local best_obj=$(echo $result | cut -d',' -f1)
    local best_run=$(echo $result | cut -d',' -f2)

    if [ $parallel_runs_per_conc -gt 1 ]; then
        # Parallel runs: log all runs data
        row_data="$elapsed_minutes,$current_time,$best_obj,$best_run"

        for ((i=1; i<=parallel_runs_per_conc; i++)); do
            local log_file="mcsqs$i.log"
            local steps="0"
            local objective="N/A"
            local status="STOPPED"

            if pgrep -f "mcsqs.*-ip=$i" > /dev/null; then
                status="RUNNING"
            fi

            if [ -f "$log_file" ]; then
                steps=$(extract_latest_step "$log_file")
                objective=$(extract_latest_objective "$log_file")
                steps=${steps:-"0"}
                objective=${objective:-"N/A"}
            fi

            row_data="$row_data,$steps,$objective,$status"
        done
    else
        # Single run: log single run data
        local steps="0"
        local objective="N/A"
        local status="STOPPED"

        if pgrep -f "mcsqs" > /dev/null; then
            status="RUNNING"
        fi

        if [ -f "mcsqs.log" ]; then
            steps=$(extract_latest_step "mcsqs.log")
            objective=$(extract_latest_objective "mcsqs.log")
            steps=${steps:-"0"}
            objective=${objective:-"N/A"}
        fi

        row_data="$elapsed_minutes,$current_time,$steps,$objective,$status"
    fi

    echo "$row_data" >> "$csv_file"
}

convert_bestsqs_to_poscar() {
    local bestsqs_file=$1
    local poscar_file=$2
    local conc=$3

    if [ ! -f "$bestsqs_file" ]; then
        echo "‚ö†Ô∏è Warning: $bestsqs_file not found"
        return 1
    fi

    echo "üîÑ Converting $bestsqs_file to $poscar_file..."

    python3 << EOF
import sys
import numpy as np
try:
    def parse_bestsqs(filename):
        with open(filename, 'r') as f:
            lines = f.readlines()

        A = np.array([[float(x) for x in lines[i].split()] for i in range(3)])
        B = np.array([[float(x) for x in lines[i].split()] for i in range(3, 6)])

        A_scaled = A * 10.331341
        final_lattice = np.dot(B, A_scaled)

        atoms = []
        atoms = []
        for i in range(6, len(lines)):
            line = lines[i].strip()
            if line:
                parts = line.split()
                if len(parts) >= 4:
                    x, y, z, element = float(parts[0]), float(parts[1]), float(parts[2]), parts[3]
                    if element.lower() in ['vac', "'vac", 'vacancy', 'x']:
                        continue
                    cart_pos = np.dot([x, y, z], A_scaled)
                    atoms.append((element, cart_pos))

        return final_lattice, atoms

    def write_poscar(lattice, atoms, filename, comment):
        from collections import defaultdict
        element_groups = defaultdict(list)
        for element, pos in atoms:
            element_groups[element].append(pos)

        elements = sorted(element_groups.keys())

        with open(filename, 'w') as f:
            f.write(f'{comment}\n')
            f.write('1.0\n')

            for vec in lattice:
                f.write(f'  {vec[0]:15.9f} {vec[1]:15.9f} {vec[2]:15.9f}\n')

            f.write(' '.join(elements) + '\n')
            f.write(' '.join(str(len(element_groups[el])) for el in elements) + '\n')

            f.write('Direct\n')
            inv_lattice = np.linalg.inv(lattice)
            for element in elements:
                for cart_pos in element_groups[element]:
                    frac_pos = np.dot(cart_pos, inv_lattice)
                    f.write(f'  {frac_pos[0]:15.9f} {frac_pos[1]:15.9f} {frac_pos[2]:15.9f}\n')

    comment = "SQS FeLa conc=$conc from $bestsqs_file"
    lattice, atoms = parse_bestsqs("$bestsqs_file")
    write_poscar(lattice, atoms, "$poscar_file", comment)
    print(f"Successfully converted $bestsqs_file to $poscar_file")
except Exception as e:
    print(f"Python script failed with error: {e}")
    import traceback
    traceback.print_exc()
    sys.exit(1)
EOF

    local python_exit_code=$?
    return $python_exit_code
}

monitor_progress() {
    local conc=$1
    local parallel_runs_per_conc=$2
    local total_time_seconds=$3
    local csv_file=$4
    local elapsed_seconds=0

    while [ $elapsed_seconds -lt $total_time_seconds ]; do
        sleep $PROGRESS_UPDATE_INTERVAL
        elapsed_seconds=$((elapsed_seconds + PROGRESS_UPDATE_INTERVAL))

        local current_time=$(date +%s)
        local global_elapsed=$((current_time - GLOBAL_START_TIME))
        local conc_elapsed=$((current_time - CONC_START_TIMES[$conc]))
        local elapsed_minutes=$((conc_elapsed / 60))

        local result=$(get_best_objective_and_run $parallel_runs_per_conc)
        local best_obj=$(echo $result | cut -d',' -f1)
        local best_run=$(echo $result | cut -d',' -f2)

        CONC_BEST_SCORES[$conc]="$best_obj"
        CONC_BEST_RUNS[$conc]="$best_run"

        log_to_csv "$csv_file" "$conc" "$parallel_runs_per_conc" "$elapsed_minutes"

        local global_time_str=$(format_elapsed_time $global_elapsed)
        local conc_time_str=$(format_elapsed_time $conc_elapsed)

        if [ "$best_run" != "N/A" ] && [ $parallel_runs_per_conc -gt 1 ]; then
            printf "[Conc %s] [%s] Global: %s | Conc %s: %s (sec %d/%d) | Best obj: %s (run %s)\n" \
                   "$conc" "$(date +'%H:%M:%S')" "$global_time_str" "$conc" "$conc_time_str" \
                   "$elapsed_seconds" "$total_time_seconds" "$best_obj" "$best_run"
        else
            printf "[Conc %s] [%s] Global: %s | Conc %s: %s (sec %d/%d) | Best obj: %s\n" \
                   "$conc" "$(date +'%H:%M:%S')" "$global_time_str" "$conc" "$conc_time_str" \
                   "$elapsed_seconds" "$total_time_seconds" "$best_obj"
        fi
    done
}

run_concentration() {
    local conc=$1
    local current_run=$2
    local total_runs=$3
    local sweep_atoms=$(printf "%.0f" $(echo "$conc * 32" | bc))
    local comp_atoms=$(echo "32 - $sweep_atoms" | bc)
    local folder="conc_${SWEEP_ELEMENT}_${conc}"
    local comp_conc=$(echo "1.0 - $conc" | bc -l)

    local time_per_conc_current=$TIME_PER_CONC_DEFAULT
    local parallel_runs_per_conc_current=$PARALLEL_RUNS_PER_CONC_DEFAULT

    if [ "$sweep_atoms" -le 1 ] || [ "$comp_atoms" -le 1 ]; then
        time_per_conc_current=0.1
        parallel_runs_per_conc_current=1
        echo ""
        echo "‚ÑπÔ∏è  Note: Single or very few atoms detected. Reducing time to $time_per_conc_current min and parallel runs to $parallel_runs_per_conc_current."
    fi

    local total_time_seconds_current=$(echo "$time_per_conc_current * 60" | bc | xargs printf "%.0f")

    CONC_START_TIMES[$conc]=$(date +%s)

    echo ""
    echo "=========================================="
    echo "($current_run/$total_runs) üî¨ Starting concentration $conc for $SWEEP_ELEMENT"
    echo "üî¢ Target atoms: $sweep_atoms $SWEEP_ELEMENT + $comp_atoms $COMPLEMENT_ELEMENT"
    echo "üèÉ Running $parallel_runs_per_conc_current parallel instances for $time_per_conc_current minutes"
    echo "=========================================="
    mkdir -p "$folder"
    cd "$folder"

    local csv_file=$(initialize_concentration_csv "$conc" "$parallel_runs_per_conc_current")
    echo "üìä CSV logging initialized: $csv_file"

    cat > rndstr.in << EOF
1.000000 1.000000 0.577350 90.00 90.00 109.47
1 0 0
0 1 0
0 0 1
0.875000 0.750000 0.750000 ${SWEEP_ELEMENT}=$conc,${COMPLEMENT_ELEMENT}=$comp_conc
0.375000 0.750000 0.250000 ${SWEEP_ELEMENT}=$conc,${COMPLEMENT_ELEMENT}=$comp_conc
0.750000 0.875000 0.250000 ${SWEEP_ELEMENT}=$conc,${COMPLEMENT_ELEMENT}=$comp_conc
0.750000 0.375000 0.750000 ${SWEEP_ELEMENT}=$conc,${COMPLEMENT_ELEMENT}=$comp_conc
0.375000 0.250000 0.750000 Zn
0.875000 0.250000 0.250000 Zn
0.250000 0.375000 0.250000 Zn
0.250000 0.875000 0.750000 Zn
0.562500 0.062500 0.500000 Fe
0.062500 0.562500 0.500000 Fe
0.562500 0.562500 0.000000 Fe
0.062500 0.062500 0.000000 Fe
0.562500 0.812500 0.750000 Fe
0.062500 0.312500 0.750000 Fe
0.562500 0.312500 0.250000 Fe
0.062500 0.812500 0.250000 Fe
0.312500 0.562500 0.750000 Fe
0.812500 0.062500 0.750000 Fe
0.312500 0.062500 0.250000 Fe
0.812500 0.562500 0.250000 Fe
0.562500 0.062500 0.000000 Fe
0.062500 0.562500 0.000000 Fe
0.562500 0.562500 0.500000 Fe
0.062500 0.062500 0.500000 Fe
0.182665 0.942335 0.019338 O
0.682665 0.442334 0.019338 O
0.182665 0.442335 0.519338 O
0.682666 0.942335 0.519338 O
0.182666 0.672996 0.750000 O
0.682665 0.172996 0.750000 O
0.182665 0.172996 0.250000 O
0.682666 0.672996 0.250000 O
0.452004 0.942335 0.750000 O
0.952004 0.442334 0.750000 O
0.452003 0.442334 0.250000 O
0.952004 0.942335 0.250000 O
0.442334 0.182665 0.019338 O
0.942335 0.682665 0.019338 O
0.442335 0.682665 0.519338 O
0.942335 0.182665 0.519338 O
0.172997 0.182665 0.750000 O
0.672997 0.682666 0.750000 O
0.172996 0.682666 0.250000 O
0.672996 0.182665 0.250000 O
0.442334 0.452003 0.750000 O
0.942335 0.952004 0.750000 O
0.442334 0.952004 0.250000 O
0.942335 0.452003 0.250000 O
0.182665 0.942335 0.480662 O
0.682665 0.442334 0.480662 O
0.182665 0.442335 0.980662 O
0.682666 0.942335 0.980662 O
0.442334 0.182665 0.480662 O
0.942335 0.682665 0.480662 O
0.442335 0.682665 0.980662 O
0.942335 0.182665 0.980662 O
EOF

    cat > sqscell.out << EOF
1

2 0 0
0 2 0
0 0 2
EOF

    echo "‚ú® Generating clusters with corrdump..."
    eval $CORRDUMP_CMD
    if [ $? -ne 0 ]; then
        echo "‚ùå ERROR: corrdump failed for concentration $conc"
        cd ..
        return 1
    fi

    echo "‚ú® Starting $parallel_runs_per_conc_current parallel mcsqs instances..."

    local pids=()
    if [ $parallel_runs_per_conc_current -gt 1 ]; then
        for ((i=1; i<=parallel_runs_per_conc_current; i++)); do
            timeout ${total_time_seconds_current}s $MCSQS_BASE_CMD -ip=$i > mcsqs$i.log 2>&1 || true &
            pids+=($!)
            echo "  ‚úÖ Started mcsqs run $i for concentration $conc (PID: $!)"
        done
    else
        timeout ${total_time_seconds_current}s $MCSQS_BASE_CMD > mcsqs.log 2>&1 || true &
        pids+=($!)
            echo "  ‚úÖ Started single mcsqs run for concentration $conc (PID: $!)"
    fi

    monitor_progress $conc $parallel_runs_per_conc_current $total_time_seconds_current "$csv_file" &
    local monitor_pid=$!

    for pid in "${pids[@]}"; do
        wait $pid || true
    done

    kill $monitor_pid 2>/dev/null || true
    wait $monitor_pid 2>/dev/null || true

    local final_elapsed_minutes=$(echo "scale=1; $time_per_conc_current" | bc)
    log_to_csv "$csv_file" "$conc" "$parallel_runs_per_conc_current" "$final_elapsed_minutes"
    echo "üìä Final optimization data logged to $csv_file"

    echo ""
    echo "=========================================="
    echo "üìÑ Processing results and converting to POSCAR format for concentration $conc..."
    echo "=========================================="

    declare -a successful_runs
    declare -a run_scores

    if [ $parallel_runs_per_conc_current -gt 1 ]; then
        for ((i=1; i<=parallel_runs_per_conc_current; i++)); do
            if [ -f "bestsqs$i.out" ]; then
                local score=$(extract_latest_objective "mcsqs$i.log")
                if [ -n "$score" ] && [ "$score" != "N/A" ] && [ "$score" != "" ]; then
                    successful_runs+=($i)
                    run_scores+=("$score")
                fi
            fi
        done
    else
        if [ -f "bestsqs.out" ]; then
            local score=$(extract_latest_objective "mcsqs.log")
            if [ -n "$score" ] && [ "$score" != "N/A" ] && [ "$score" != "" ]; then
                successful_runs+=(1)
                run_scores+=("$score")
            fi
        fi
    fi

    if [ ${#successful_runs[@]} -eq 0 ]; then
        echo "‚ùå No successful runs for concentration $conc"
        cd ..
        return 1
    fi

echo "Found ${#successful_runs[@]} successful runs"

    local sorted_indices=()
    for ((i=0; i<${#successful_runs[@]}; i++)); do
        sorted_indices+=($i)
    done

    for ((i=0; i<${#sorted_indices[@]}; i++)); do
        for ((j=i+1; j<${#sorted_indices[@]}; j++)); do
            local idx_i=${sorted_indices[i]}
            local idx_j=${sorted_indices[j]}
            local score_i=${run_scores[idx_i]}
            local score_j=${run_scores[idx_j]}
            if awk "BEGIN {exit !($score_j < $score_i)}" 2>/dev/null; then
                local temp=${sorted_indices[i]}
                sorted_indices[i]=${sorted_indices[j]}
                sorted_indices[j]=$temp
            fi
        done
    done

    echo "Converting ${#successful_runs[@]} successful runs to POSCAR format:"
    local best_run_found=false
    local best_poscar_filename=""

    for ((rank=0; rank<${#sorted_indices[@]}; rank++)); do
        local idx=${sorted_indices[rank]}
        local run_num=${successful_runs[idx]}
        local score=${run_scores[idx]}

        local bestsqs_filename
        local poscar_filename
        if [ $parallel_runs_per_conc_current -gt 1 ]; then
            bestsqs_filename="bestsqs${run_num}.out"
            poscar_filename="POSCAR_$((rank + 1))"
        else
            bestsqs_filename="bestsqs.out"
            poscar_filename="POSCAR"
        fi

        if convert_bestsqs_to_poscar "$bestsqs_filename" "$poscar_filename" "$conc"; then
            if [ $parallel_runs_per_conc_current -gt 1 ]; then
                echo "  ‚úîÔ∏è POSCAR_$((rank + 1)): Run $run_num (score: $score)"
            else
                echo "  ‚úîÔ∏è POSCAR: Run 1 (score: $score)"
            fi

            if [ $rank -eq 0 ]; then
                best_run_found=true
                best_poscar_filename="$poscar_filename"
                if [ $parallel_runs_per_conc_current -gt 1 ]; then
                    cp "POSCAR_1" "POSCAR"
                    echo "  üèÜ ‚Üí Best result: POSCAR_1 (also saved as POSCAR)"
                else
                    echo "  üèÜ ‚Üí Best result: POSCAR"
                fi
            fi
        else
            if [ $parallel_runs_per_conc_current -gt 1 ]; then
                echo "  ‚ùå Failed to convert run $run_num to POSCAR"
            else
                echo "  ‚ùå Failed to convert single run to POSCAR"
            fi
        fi
    done

    if [ "$best_run_found" = true ]; then
        local best_idx=${sorted_indices[0]}
        local best_score=${run_scores[best_idx]}
        echo ""
        echo "‚úÖ Concentration $conc completed successfully"
        echo "‚ú® Best result has score: $best_score"
        if [ $parallel_runs_per_conc_current -gt 1 ]; then
            echo "üìÇ Generated ${#successful_runs[@]} POSCAR files (POSCAR_1 to POSCAR_${#successful_runs[@]})"
        else
            echo "üìÇ Generated POSCAR file"
        fi

        local file_prefix="$2"
        cp "POSCAR" "../best_poscars/${file_prefix}_POSCAR-${conc}"
        echo "üìÅ Copied best POSCAR to ../best_poscars/${file_prefix}_POSCAR-${conc}"

    else
        echo "‚ùå Failed to convert any results for concentration $conc"
    fi

    cd ..
}

export -f run_concentration
export -f monitor_progress
export -f format_elapsed_time
export -f get_best_objective_and_run
export -f convert_bestsqs_to_poscar
export -f extract_latest_objective
export -f extract_latest_objective
export -f extract_latest_step
export -f initialize_concentration_csv
export -f log_to_csv

concentrations=(
    0.03125
    0.0625
    0.09375
    0.125
    0.15625
    0.1875
    0.21875
    0.25
    0.28125
    0.3125
    0.34375
    0.375
    0.40625
    0.4375
    0.46875
    0.5
    0.53125
    0.5625
    0.59375
    0.625
    0.65625
    0.6875
    0.71875
    0.75
    0.78125
    0.8125
    0.84375
    0.875
    0.90625
    0.9375
    0.96875
)

echo "Will process ${#concentrations[@]} concentrations with a default of $PARALLEL_RUNS_PER_CONC_DEFAULT parallel runs each"
echo "Total estimated time: $(echo "${#concentrations[@]} * $TIME_PER_CONC_DEFAULT" | bc -l | xargs printf "%.1f") minutes"
echo "Maximum concurrent jobs: $MAX_PARALLEL"
echo ""

total_concentrations=${#concentrations[@]}
for ((i=0; i<total_concentrations; i++)); do
    while [ $(jobs -r | wc -l) -ge $MAX_PARALLEL ]; do
        sleep 5
    done

    run_concentration "${concentrations[i]}" "$((i+1))" "$total_concentrations" &
done

wait

echo ""
echo "========================================"
echo "üèÅ All concentrations completed!"
echo "========================================"

echo "üìã Summary of generated files:"
echo "- üìÅ Each concentration folder contains POSCAR_1, POSCAR_2, etc. (ordered by objective function)"
echo "- üìÅ A copy of each best POSCAR is saved in the best_poscars folder"

echo "‚úÖ Concentration sweep completed successfully!"